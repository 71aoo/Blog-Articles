## Laravel5.7之CVE-2019-9081



### 如何RCE

在**Illuminate\Foundation\Testing\PendingCommand.php**下的**PendingCommand**类存在**__construct()**方法

```php
    public function __construct($test, $app, $command, $parameters)
    {
        $this->app = $app;
        $this->test = $test;
        $this->command = $command;
        $this->parameters = $parameters;
    }
```

四个参数都可控，且作用如下：

```php
$this->app;         //一个实例化的类 Illuminate\Foundation\Application
$this->test;        //一个实例化的类 Illuminate\Auth\GenericUser
$this->command;     //要执行的php函数
$this->parameters;  //要执行的php函数的参数，需为数组
```

若控制

```php
$this->command = 'system';
$this->parameters = array('whoami');
```

则可以达到执行恶意代码。

----

### 详细过程

在**Illuminate\Foundation\Testing\PendingCommand.php**下的**PendingCommand**类存在**__destruct()**方法

```php
public function __destruct()
    {
        if ($this->hasExecuted) {
            return;
        }

        $this->run();
    }
```

Ps：**__destruct()**是反序列化利用的一个重要的点

因为本身在**PendingCommand**类下，**$this->hasExecuted**就设置为**false**

```php
protected $hasExecuted = false;
```

所以直接执行**$this->run()**，目的很明确，只要让它无错误的执行完run()函数就行，**run()**代码如下：

```php
public function run()
    {
        $this->hasExecuted = true;

        $this->mockConsoleOutput();

        try {
            $exitCode = $this->app[Kernel::class]->call($this->command, $this->parameters);
        } catch (NoMatchingExpectationException $e) {
            if ($e->getMethodName() === 'askQuestion') {
                $this->test->fail('Unexpected question "'.$e->getActualArguments()[0]->getQuestion().'" was asked.');
            }

            throw $e;
        }

        if ($this->expectedExitCode !== null) {
            $this->test->assertEquals(
                $this->expectedExitCode, $exitCode,
                "Expected status code {$this->expectedExitCode} but received {$exitCode}."
            );
        }

        return $exitCode;
    }
```

直接执行

```php
$this->mockConsoleOutput();
```

**mockConsoleOutput()**代码如下：

```php
 protected function mockConsoleOutput()
    {
        $mock = Mockery::mock(OutputStyle::class.'[askQuestion]', [
            (new ArrayInput($this->parameters)), $this->createABufferedOutputMock(),
        ]);

        foreach ($this->test->expectedQuestions as $i => $question) {
            $mock->shouldReceive('askQuestion')
                ->once()
                ->ordered()
                ->with(Mockery::on(function ($argument) use ($question) {
                    return $argument->getQuestion() == $question[0];
                }))
                ->andReturnUsing(function () use ($question, $i) {
                    unset($this->test->expectedQuestions[$i]);

                    return $question[1];
                });
        }

        $this->app->bind(OutputStyle::class, function () use ($mock) {
            return $mock;
        });
    }
```

